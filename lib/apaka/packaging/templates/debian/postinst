#!/usr/bin/perl

# An identical script is used for postinst and postrm

use strict;
use File::Find;
use YAML::XS qw(LoadFile DumpFile);

my $apaka_release_install_dir = "<%= rock_release_install_directory %>";
my $apaka_pkg_install_dir = "<%= rock_install_directory %>";

# Trim a trim
sub trim { my $s = shift; $s =~ s/^\s+|\s+$//g; return $s };

sub update_index_html() {
    my $apaka_release_doc_install_dir = "$apaka_release_install_dir/share/doc";
    my $apaka_doc_dirs = "$apaka_release_install_dir/*/share/doc";

    #make sure $apaka_release_doc_install_dir exists
    system("mkdir","-p",$apaka_release_doc_install_dir);
    #collect candidate files
    my @dirs = glob("$apaka_doc_dirs/*");
    my @indexfiles;
    my @indexes = map {
	my $dir = $_;
        # Identify package by parent folder of
        # share folder
        $dir =~ m!/([^/]+)\/share/+!;
	my $pkg = $1;
	$dir =~ s!/+$!!;

        @indexfiles = ();
        find(\&wanted, $dir);
        sub wanted {
            return if ! -e;
            if($File::Find::name =~ /\/index.htm/)
            {
                push @indexfiles, $File::Find::name;
            }
        }
	my @candidates = sort {
	    length($a) <=> length($b);
	} @indexfiles;

	my $idx = $candidates[0];
	$idx ? ({ pkg => $pkg, index => $idx }) : ();
    } @dirs;

    #create html on the fly. we can only rely on perl core packages.
    my $index;
    open $index,">","$apaka_release_doc_install_dir/index.html" or die "Could not create $apaka_release_doc_install_dir/index.html";
    print $index <<"[END]";
<html>
<head>
<title>Rock package documentation index</title>
</head>
<body>
<h1>Rock package documentation index</h1>
<ul>
[END]
    foreach my $idx (@indexes) {
	my ($pkg,$file) = ($idx->{pkg},$idx->{index});
	print $index <<"[END]";
<li> <a href="$file">$pkg</a>
[END]
    }
    print $index <<"[END]";
</ul>
</body>
</html>
[END]
    close $index;

    # Cleaning up if no packages can be found
    my $number_of_pkgs = @indexes;
    if ($number_of_pkgs == 0) {
        my $index_file = "$apaka_release_doc_install_dir/index.html";
        if(-e $index_file) {
            unlink($index_file);
        }
    }
}

# Update the env.yml file with the information provided in the env.yml
# file
sub update_env_yml() {

    my $env_data = LoadFile("$apaka_pkg_install_dir/env.yml");

    my $append_file = "$apaka_pkg_install_dir/env.yml.append";
    if (-e $append_file)
    {
        open my $handle, '<', $append_file;
        while (<$handle>) {
            my ($variable, $value) = split / /;
            if(exists $env_data->{$variable})
            {
                push( @{ $env_data->{$variable}->{':values'} }, trim($value) )
            } else {
                $env_data->{$variable} = { ":type" => ":add",
                    ":values" => [ trim($value) ] };
            }
        }
        close $handle;
        DumpFile("$apaka_pkg_install_dir/env.yml",$env_data);

        unlink($append_file)
    }
}

my $cmd = shift;

if ($0 =~ /postinst$/) {
    if ($cmd == "configure") {
	#called when the package files have been installed during installation
	#of the package
	update_index_html();
        update_env_yml();
    } elsif ($cmd == "abort-upgrade") {
	#called during package upgrade/install
    } elsif ($cmd == "abort-remove") {
	#called during package upgrade/install
    } elsif ($cmd == "abort-deconfigure") {
	#called during package upgrade/install
    }
} elsif ($0 =~ /postrm$/) {
    if ($cmd == "remove") {
	#called after removal of the packages files during removal of the
	#package
	update_index_html();
    } elsif ($cmd == "purge") {
	#called after "remove"
    } elsif ($cmd == "upgrade") {
	#called during package upgrade/install
    } elsif ($cmd == "disappear") {
	#called during package upgrade/install
    } elsif ($cmd == "failed-upgrade") {
	#called during package upgrade/install
    } elsif ($cmd == "abort-install") {
	#called during package upgrade/install
    } elsif ($cmd == "abort-upgrade") {
	#called during package upgrade/install
    }
}
